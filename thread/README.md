# JAVA 线程和操作系统线程
## 1. 系统线程如何调用
> 对于 JVM 来讲 Thread 只是一个对象,而真正创建线程的是native 方法调用了系统函数 pthread_create,类似的C 源码如下,在MACOS中 pthread的使用 Demo 如下:
```c
// 线程头文件 
#include <pthread.h>
// 标准输入流头文件 用于使用printf方法
#include <stdio.h>
// 用于使用usleep方法
#include <unistd.h>
void *run(void *arguments){
  while(1){
    printf("thread 1 run\n");
    usleep(100);
  }

}
void main(){
  
  pthread_t pid;
  // 第一个参数线程ID 
  // 第二个参数线程属性
  // 第三个参数线程主体函数(类似JAVA中的run方法)
  // 第四个参数线程主体函数的参数引用 比如可以往arguments 传递参数
  int err = pthread_create(&pid, NULL,run,NULL);
  while(1){
    usleep(100);
    printf("main run\n");
  }
}
```
使用`gcc -o th **.c` 编译后运行th会发现main 函数和 run 函数会交替打印内容类似java 中的多线程
## 2. Java start 调用 run 模拟(Mac OSX 如何编写native 方法)
参考 [ORACLE 文档](https://docs.oracle.com/javase/8/docs/technotes/guides/install/mac_jdk.html)

1. 首先编写一个带有native方法的java 类
```java
class MyThread {
    static {
        // 指定动态库链接在当前目录 方便示例代码
        System.setProperty("java.library.path", ".");
        // 指定动态库名称
        System.loadLibrary("myThreadNative");
    }

    public void run() {
        // 示例打印信息
        System.out.println(Thread.currentThread().getName() + ":I am running");
    }

    /**
     * java 的start 不是native 方法 但是java start0 是native 方法
     * 这里只是猜想示例并非真正实现
     */
    public native void start();

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```
2. `javac Mythread.java` 编译通过
3. `javah Mythread` 编译产生头文件 Mythread.h (类似java的Interface,一般用于方法声明)预处理等信息,具体参照
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class MyThread */

#ifndef _Included_MyThread
#define _Included_MyThread
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     MyThread
 * Method:    start
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_MyThread_start
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```
4. 编写一个 C 文件实现当前方法并定义一个`JNIEXPORT void JNICALL Java_MyThread_start  (JNIEnv *, jobject);`方法 并从内部反射回调Mythread `run` 方法

```c
#include <stdio.h>
#include <MyThread.h>

JNIEXPORT void JNICALL Java_MyThread_start(JNIEnv* env, jobject jobj){
     // 获取运行时的class
     jclass jcls = (*env)->FindClass(env,"MyThread");
     // 查询run方法
     jmethodID jrun = (*env)->GetMethodID(env,jcls,"run","()V");
     // 执行run方法
     jint i= (*env)->CallIntMethod(env,jobj,jrun,NULL);
}
```
5. 使用 gcc 编译,首先jni.h 不是系统类库,必须告诉gcc 查找路径,其次还需要告诉gcc 当前生成的Mythread.h 所在目录,最后按照 oracle 规范返回文件名需要`lib` 开头,`.jnilib`结尾所以使用以下命令:
```bash
gcc -fPIC -I $JAVA_HOME/include \
    -I $JAVA_HOME/include/darwin \
    -I . -shared \
    -o libmyThreadNative.jnilib MyJavaThread.c
```
6. 执行成功
```bash
+ java MyThread
main:I am running
```
## 3. 总结
通过java 调用 native 方法并从native 方法调用java 方法是可以实现的,实际上,hotspot 源码中创建线程的方式也和本示例类似,流程为Thread 对象 start方法-> start0 native 方法->hotspot 创建线程,方法体内回调run方法,***但使用的方式和当前方式实现细节并不一致***。