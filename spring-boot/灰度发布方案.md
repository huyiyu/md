# 基于Spring-cloud-Gateway和spring-cloud-openfeign 的灰度发布
## 背景
> 公司使用 基于spring-cloud 全家桶相关微服务,由于更新迭代频繁,用户不能容忍停机,考虑灰度发布和流量切分,经过调研给出了一套后端的灰度发布方案
## 原理
> 我们知道,gateway 和feign 都是动态路由,基于服务名转发,基于spring cloud 的规范,需要引入实现了 DiscoverClient 的客户端获得应用和应用实例然后转发;
我们只需要在gateway fitler 中设置灰度的规则和对应灰度版本并放置于请求头上,在loadbalancer 阶段去解析gateway添加的请求头来实现流量的切分,按照业界的方式
再开启灰度开关后,用户流量只允许走release 版本,而测试用户可以根据配置的规则走特定新特性的版本.图网上已经有人画得足够多了,我这边就不班门弄斧了.


## 实施
### 1.请求添加 traceID
> 在Gateway上添加 responseHeader,tid tid 由skywalking 生成,skywalking 接入可自行查询skywalking 文档,是基于javaagent 的;然后gatewayFilter 不能直接设置TraceContext.getTraceId();原因是TraceContext 是基于threadLocal 的,具体请参考github [how SpringCloud Gateway add traceId to response header](https://github.com/apache/skywalking/discussions/10686)
代码如下


```java
public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    String traceId = WebFluxSkywalkingOperators.continueTracing(exchange, TraceContext::traceId);
    exchange.getResponse().getHeaders().set("tid",traceId);
}
```
使用时请引入skywalking 相关包,并且版本不低于8.13.0
```xml
<dependency>
  <groupId>org.apache.skywalking</groupId>
  <artifactId>apm-toolkit-trace</artifactId>
  <version>${skywalking.version}</version>
</dependency>
<dependency>
  <groupId>org.apache.skywalking</groupId>
  <artifactId>apm-toolkit-webflux</artifactId>
  <version>${skywalking.version}</version>
</dependency>
```
### 2.自定义GlobalFilter
> 如果为了前端灰度工作,可以把当前内容逻辑移动到 apisix 上完成,下面提供的是Gateway 的实现,该内容设计了一个规则匹配的逻辑,规则如下
1. 如果未开启灰度则所有内容都不干预
2. 灰度开关开启后,所有流量只允许走对应的灰度版本和稳定版本
3. 灰度有规则匹配器,需要实现match方法来尝试为流量匹配特定的灰度规则,按配置顺序匹配靠前的第一个规则
4. 如果匹配通过,则认为该流量是灰度流量,那么只允许走**对应**的灰度版本的流量和保底的*稳定版本*的流量(如果没有灰度应用)
5. 如果匹配不通过则认为是正常用户流量,只能允许走线上稳定版本
6. filter 不做流量处理,只添加请求header,在loadBalancer部分做逻辑判断
7. 为了filter 能早于loadBalancer执行,需要把filter 放到最优先执行的顺序使用spring 的规范 **PirorityOrder** 接口
实现代码如下:
```java
public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    // 设置traceId 方便后续服务定位
    String traceId = WebFluxSkywalkingOperators.continueTracing(exchange, TraceContext::traceId);
    exchange.getResponse().getHeaders().set("tid",traceId);
    ServerHttpRequest request = exchange.getRequest();
    Builder mutate = request.mutate();
    // 如果灰度开关打开,该开关控制在nacos 上 通过配置下发的形式通知到gateway
    if (greyDeployProperties.getOnGreyDeploy()){
        // 清除灰度相关的请求头避免外部攻击
        mutate.headers(this::removeGreyHeaders)
            .header(GreyConstant.TID, traceId) // 把tid 的请求头添加到header里
            .header(GreyConstant.IN_GREY_DEPLOY,"true")// 提示下游loadBalancer当前正在进行灰度发布
        // 把当前exchange 和所有灰度规则传给规则执行器,匹配最佳的灰度规则
        // 如果没有匹配上会返回默认规则 greyFlow=false greyVersion=default
        GreyRule rule=RuleruleExecutor.getFirst(exchange, greyDeploy)
        mutate.header(GreyConstant.HEADER_GREY_FLOW,rule.getGreyFlow().toString())
            .header(GreyConstant.HEADER_GREY_FLOW,rule.getGreyFlow().toString());
    }
}

// 规则执行器代码逻辑如下
public class RuleExecutor {

    private static final GreyRule DEFAULT_GREY_RULE = new GreyRule()
                .setAuthor(DEFAULT_AUTHOR)
                .setHostAddress(DEFAULT_IP)
                .setGreyFlow(false)
                .setGreyVersion(DEFAULT);

    @Setter
    private Map<RuleType, RuleMatcher> ruleMatcherMap;

    public Optional<GreyRule> getFirst(ServerWebExchange exchange, List<GreyRule> rules) {
        for (GreyRule rule : rules){
            RuleMatcher ruleMatcher = ruleMatcherMap.get(rule.GetAction());
            // 执行rule 返回true 说明结果成立 这里以IPRuleMatcher为例展示
            if (ruleMatcher != null && ruleMatcher.match(exchange, rule)){
                return rule
            }
        }
    }
}

// ipRuleMatcher 的匹配方法分析
public boolean match(ServerWebExchange exchange,GreyRule greyRule){
    try{
        // 获取x-forwarded-ip 列表并获取第一个IP作为机器IP
        String ip =XForwardRemoteAddressResolver.trustAll()
            .resolve(exchange)
            .getAddress()
            .getHostAdress();

        return StringUtils.equals(ip, greyRule.getHostAdress());
    } catch (Exception e){
        log.warn("获取不到xForward初始化IP认为规则不匹配")
    }
    return false;
}
```
### 3.配置自定义metadata
我们使用了nacos 注册中心,添加源信息只需要在应用环境变量中添加配置的metadata,视使用的部署环境选择添加方式,可以是系统参数,命令行参数,环境变量
```properties
spring.cloud.nacos.discovery.metadata.is-release=true
spring.cloud.nacos.discovery.metadata.image-version=true
```


### 4.自定义loadBalancer

#### 框架方面的坑
> 高版本feign 不在使用neflix-ribbon,而是使用异步
根据源代码阅读的经验,需要新增loadBalancer时 需要为加载的Config 配置 **@LoadBalancerClients(class=当前JavaConfig类)**,原因是因为子Context 只会加载@LoadBalancerClient 加载的类,为避免父容器的误加载,可检查环境变量中的 `LoadBalancerClientFactory.PROPERTY_NAME`是否存在,父容器一定不存在该属性;同时为了将源请求头转移到LoadBalancer 中获取,需要实现一个RequestInterceptor 使request 数据从RequestContextHolder 的ThreadLocal中转移到feign 调用过程中

```java
@Configuration
@LoadBalancerClients(defaultConfiguration = SubContextConfig.class)
public class SubContextConfig {

    @Bean
    @ConditionalOnProperty(name = LoadBalancerClientFactory.PROPERTY_NAME)
    public ReactorLoadBalancer<ServiceInstance> greyGroupLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new GreyReleaseLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);
    }

}

@Configuration
// 为了在gateway重用该内容,gateway 可以不加载RequestInterceptor
@ConditionalOnClass(RequestInterceptor.class)
public class GreyReleaseConfig {
    @Bean
    public VersionPirorityInterceptor greyReleaseInterceptor() {
        return new VersionPirorityInterceptor();
    }
}
```
#### 核心代码
```java
public class VersionPirorityInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();
        // 从源请求中搬运 灰度所需的Header,网关转发不用考虑该步骤
        copyHeader(template, request);
    }

    private void copyHeader(RequestTemplate template, HttpServletRequest request) {
        template.header(HEADER_GREY_VERSION, request.getHeader(HEADER_GREY_VERSION));
        template.header(HEADER_GREY_FLOW, request.getHeader(HEADER_GREY_FLOW));
        template.header(HEADER_RELEASE_VERSION, request.getHeader(HEADER_RELEASE_VERSION));
        template.header(HEADER_IN_GREY_DEPLOY, request.getHeader(HEADER_IN_GREY_DEPLOY));
    }
}
// 对LoadBalancer 进行扩展
public class GreyReleaseLoadBalancer implements ReactorServiceInstanceLoadBalancer {
    
    private final String serviceId;// 当前调用的服务名
    private final ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider;

    /**
     * @param serviceInstanceListSupplierProvider a provider of
     *                                            {@link ServiceInstanceListSupplier} that will be used to get available instances
     * @param serviceId                           id of the service for which to choose an instance
     */
    public GreyReleaseLoadBalancer(ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider, String serviceId) {
        this.serviceId = serviceId;
        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;
    }

    // loadBalancer 采用异步编程模型这个方法是入口
    public Mono<Response<ServiceInstance>> choose(Request request) {
        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider
                .getIfAvailable(NoopServiceInstanceListSupplier::new);
        return supplier.get(request).next()
                .map(serviceInstances -> processInstanceResponse(supplier, serviceInstances, request));
    }

    private Response<ServiceInstance> processInstanceResponse(ServiceInstanceListSupplier supplier,List<ServiceInstance> serviceInstances, Request request) {
        Response<ServiceInstance> serviceInstanceResponse = getInstanceResponse(serviceInstances, request);
        if (supplier instanceof SelectedInstanceCallback && serviceInstanceResponse.hasServer()) {
            ((SelectedInstanceCallback) supplier).selectedServiceInstance(serviceInstanceResponse.getServer());
        }
        return serviceInstanceResponse;
    }

    // 从这个方法对nacos 上的实例进行干预
    private Response<ServiceInstance> getInstanceResponse(List<ServiceInstance> instances, Request request) {
        HttpHeaders httpHeaders = ((RequestDataContext) request.getContext()).getClientRequest().getHeaders();
        ServiceInstance serviceInstance = null;
        GreyReleaseEntity greyReleaseEntity = parseGreyEntity(httpHeaders);
        // 此处为了避免单台机器负载过大,所有流量按roundRobin 轮询多台灰度机器
        if (greyReleaseEntity.isInGreyDeploy()){
            // 灰度发布时 先开开关,后部署应用
            serviceInstance = doGreyDeploy(instances, serviceInstance, greyReleaseEntity);
        }else {
            // 没有灰度发布时,直接走roundRobin 避免 instance 集合过大遍历时间慢
            serviceInstance = RoundRobin.withRoundRobin(instances);
        }
        if (serviceInstance == null){
            log.warn("No servers available for service: " + serviceId);
            return new EmptyResponse();
        }
        return new DefaultResponse(serviceInstance);
    }

    // 自定义基于灰度相关的代码
    private ServiceInstance doGreyDeploy(List<ServiceInstance> instances,  GreyReleaseEntity greyReleaseEntity) {
        Map<String, List<ServiceInstance>> collect = instances.stream()
                .collect(Collectors.groupingBy(this::getInstanceVersion, Collectors.toList()));
        if (greyReleaseEntity.isGreyFlow()){
            serviceInstance = RoundRobin.withRoundRobin(collect.get(greyReleaseEntity.getGreyVersion()));
        }
        if (serviceInstance == null){
            // 灰度发布过程中 灰度版本流量匹配失败或者正常版本流量都只能命中release—version
            serviceInstance = RoundRobin.withRoundRobin(collect.get(greyReleaseEntity.getReleaseVersion()));
        }
        return serviceInstance;
    }

    private String getInstanceVersion(ServiceInstance t) {
        return t.getMetadata().getOrDefault(IMAGE_VERSION,"default");
    }

    private GreyReleaseEntity parseGreyEntity(HttpHeaders httpHeaders) {
        GreyReleaseEntity greyReleaseEntity = new GreyReleaseEntity()
                .setGreyFlow(Boolean.valueOf(httpHeaders.getFirst(HEADER_GREY_FLOW)))
                .setGreyVersion(httpHeaders.getFirst(HEADER_GREY_VERSION))
                .setInGreyDeploy(Boolean.valueOf(httpHeaders.getFirst(HEADER_IN_GREY_DEPLOY)))
                .setReleaseVersion(httpHeaders.getFirst(HEADER_RELEASE_VERSION));
        if (log.isDebugEnabled()) {
            log.debug("获取到灰度对象结果为:{}", greyReleaseEntity);
        }
        return greyReleaseEntity;
    }
}
```
## 操作步骤
1. 配置rule规则
2. 开启灰度开关
3. 发布灰度应用
4. 进行测试
5. 测试通过后开启流量全切灰度(使用AllRuleMatcher,此时所有流量全部切换到已经发布的灰度应用里,可以启动主版本测试)
6. 发布正式应用
7. 关闭灰度开关
## 注意事项
1. 执行灰度发布一定要严格按照上文顺序操作,否则可能部分流量出错的现象
2. 消息队列或外部系统考虑不在本次讨论范围,业务侧处理



## 后续优化
1. 支持灰度配置下发,将metadata 数据迁移到配置中心上而不是应用本身