# kubernetes in action 
## 1.1 系统需求(流行的背景)
> **背景**: 随着微服务的流行使得部署组建增多和数据中心的增长,对于组件部署在什么地方变得越来越难以决策(需要权衡更多的因素,机器性能怎么样啊,网络怎么样啊)手动做所有的事情变得异常繁琐,需要一些自动化的措施。包含 ***自动调度***，***配置***，***监管***，***故障处理***。这正是kubenetes 的用武之地。
kubernetes 使开发者能完全脱离运维团队的帮助，自主部署应用,并且控制部署频率。同时让运维团队监控整个系统，在硬件故障的时候重新调度应用,系统管理员只需监管kubernetes 状态,而开发人员去监管应用。kubernetes 抽象了数据中心的硬件基础设施,使得对外暴露的只是一个巨大的资源池。它让我们在部署和运行组件时，不用关心底层使用的具体服务器。此外,生产环境会随着时间推移逐渐和开发测试变得不一致,为了减少这种问题,让开发环境和生产环境尽可能运行在一致的环境上(拥有相同的操作系统,库,网络环境，系统配置和其他的所有条件)这也是容器化流行的原因之一
## 1.2 介绍容器技术
> 当把不同的组件部署在同一台机器时,有可能他们需要两个互相冲突的不同版本的系统依赖库,少量的组件时可以使用虚拟机解决,当组件足够多的时候,使用虚拟机就造成了资源的浪费,**容器允许组件在同一台机器部署不同系统依赖的服务,并将它们相互隔离,提供不同的系统环境**容器和虚拟机的区别是:***不同的容器是运行在同一个系统上的进程***,而使用虚拟机是跨操作系统的；***这也使得容器更加轻量级,启动速度更快,因为不需要维护默认的系统服务***。容器通过 ***名称空间*** 和 ***控制组*** 实现了资源的隔离,名称空间提供隔离的系统视图(文件系统 网卡 进程 主机名),而控制组提供进程所能使用的资源的限制(CPU 内存 带宽等) docker,rkt,podman,等都是容器技术的具体实现,也是k8s 的容器运行时组件
## 1.3 kubernetes 介绍
> 初衷: kubernetes 是google 内部 基于brog 和 omega 等其他系统实践开源系统,它使得你在数以千计的节点上运行软件就像在同一个节点上一样。

### 1.3.1 集群架构
> 从节点上面分,kubernetes 分为主节点和工作节点,
主节点上运行着kubernetes 的控制面板,工作节点上运行着调度的应用和部分的管理组件

* 控制面板
    * api-server: 提供一组http API接受外部发送的指令
    * kube-scheduler: 为每个应用分配一个调度节点
    * controller-manager: 执行集群的功能,如复制组件，跟踪工作节点，处理节点失败等
    * etcd: 做整个系统的配置中心,存储系统配置
* 工作节点
    * docker,rkt或其他的容器运行时
    * kubelet: 接受api-server 的请求,管理所在节点的容器
    * kube-proxy: 转发容器流量和负载均衡
### 1.3.2 在kubernetes 中运行应用
1. 打包推送一个或多个应用的镜像到registry
2. 向api-server 发送一个或多个应用的描述(这个描述包含镜像名称,运行节点等等一系列必填的可选的描述信息)
3. api-server 根据这些信息指挥 scheduler 分配节点
4. scheduler 指挥对应节点 kubelet 下载镜像启动容器
5. 容器运行后k8s 通过各种检查确定容器存活或就绪 容器崩溃后会触发重启,如果节点崩溃会把该节点的所有容器调度到其他存活节点上
6. 容器运行时可以手动决定是否扩展副本数,或者让kubernetes 自动决定是否扩展
7. 当容器不断的在kuenetes 内部调度时需要知道如何访问,通过kube-proxy服务可以维护一个IP或者主机名指向特定的一个或多个pod 并通过内部DNS查询

### 1.3.3 使用 k8s 的好处
* 简化应用部署: 为所有工作节点公开同一个部署平面，开发人员可以通过API命令k8s 部署
* 更好地利用硬件: k8s 通过你的描述信息或者自动选择部署机器,可以优化每个节点的使用
* 健康检查和自我修复: 通过探针不断的监控运行的应用,一旦发现状态异常,自动重新调度应用
* 自动扩容: 无需不断监控单个应用的负载,而是让k8s 去自动根据需要增加或减少副本数量


