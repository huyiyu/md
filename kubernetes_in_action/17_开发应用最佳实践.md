# 开发应用最佳实现
## 集中一切资源
> k8s提供了那么多的资源,我们应该在合理的地方使用合理的资源清单去创建pod 去做配置管理去暴露服务等

* Service: 当需要提供网络联通或微服务调用的时候使用
    * NodePort: 内网最常用的节点端口的形式
    * LoadBalancer: 公有云使用的类似NodePort 的功能
    * ClusterIP: 微服务调用,但是一般不直接使用service IP 而是serviceName 或 DNS 记录
    * Headless: 一般用于StatefulSet 类型的服务暴露,不会生成ClusterIP而是把POD IP通过dns解析出去
* Ingress: 用于简化Service 配置统一外部出口所使用
* ConfigMap: 用于配置明文信息的配置资源,可以通过引用到环境变量或挂载到磁盘的方式读取内容
* Secret: 用于配置敏感信息的配置资源,一般展示为base64编码,可以通过引用到环境变量或挂载到磁盘的方式读取内容
* ServiceAccount: 保存一个POD 访问 api-server 时的认证信息,同时可挂载默认secret,镜像拉取secret
* Deployment: 用于部署无状态的应用,通常是开发人员开发的微服务系统,通过管理pod模板间接创建POD
* StatefulSet: 用于部署有状态的应用,通常是应用中间件系统,必须考虑节点漂移和磁盘挂载等内容
* DaemonSet: 提供系统级别服务的运行,通常是监控系统,网络插件,日志系统等
* Job: 系统管理员(运维工程师)提供的一次执行的任务,会在执行完成后退出容器,pod显示完成状态
* CronJob: 系统管理员提供的定期执行的任务,会在规定时间生成Job资源然后执行

## 了解POD的生命周期
* 应用 pod 大概率会在运行过程中被杀死(健康检查不通过,BestEffort干掉),然后在其他节点重新复活
    * 要从开发层面提前预估 **应用被重新调度后 IP和网络状态会发生变化**,如果不希望发生此类变化,最好使用StatefulSet,但仍然无法避免IP的变化
    * 容器运行时 **写入磁盘的数据只是临时缓存,假如应用被重新调度,原先的数据便消失了** 如果需要写入磁盘,应考虑采用磁盘挂载的形式。
* 如果一个 POD 一直处于崩溃状态,kubelet 会不断重启他们,每次重启的间隔将以指数级增加直到达到5分钟,最终将一直以5分钟的间隔重启
* kubernetes 没有类似docker-compose DependsOn的解决方案,当服务相互依赖时,考虑使用**initContainer延迟POD启动** 以达到按顺序启动的方案,但是最好的方案是 **设计相互解耦的应用关系**
* 定义容器的生命周期钩子,生命周期钩子是针对容器的而不是pod的,pod结束不代表容器结束
    * **启动后钩子在主进程启动后立即执行**,而非健康检查通过后,如果启动后钩子运行出错,应用直接被杀死并提示,且钩子运行的的内容不会打印到控制台,也会造成调试的复杂性,考虑使用写emptyDir实现调试
    * **容器要被结束之前执行结束钩子**;当一个容器需要终止运行的时候,kubelet会先执行停止前钩子,并且仅在执行完成钩子程序后才会向容器进程发送SIGTERM信号(如果这个进程没有优雅地终止运行,则会被杀死)和启动前钩子不一样的是,无论终止前钩子执行是否成功,容器始终会被终止,不建议在preStop 阶段发送SIGTERM信号给应用而应该让kubelet去发送,如果应用没有接收到这个内容应该去检查应用是否以 exec 而非shell形式启动
* pod 的关闭流程: pod的关闭时通过API服务器删除POD 对象来触发的,当收到HTTP DELETE 的请求后,apiServer没有立即删除pod对象,而是给pod标记一个deletionTimeStamp值,标记着这个POD的终止过程的开始,当kubelet意识到需要终止pod之后,会给pod的每个容器一个终止宽限期来进行优雅停机,此时进程开始计时并按顺序执行以下事件
    * 执行停止前钩子,并等待其执行完成
    * 向主进程发送 SIGTERM 信号
    * 等待容器优雅的关闭,或者终止宽限期超时 默认为30s 尽量要设置的足够长,这个参数也可以在执行delete 命令的时候覆盖
    * 如果主进程没有优雅的关闭,使用 SIGKILL 信号强制终止进程
* 合理对待容器关闭操作: 不推荐在容器终止时编写耗时的工作干预容器关闭,而应该启动一个pod(创建一个job资源) 去专注容器关闭的清理工作
## 确保所有客户端请求都得到妥善处理
* 确保**pod 启动完成后**才能接受请求,通过配置就绪探针实现
* **让 pod 在结束前等待一段时间** 解决当前仍然在处理的请求,可通过preStop 睡眠解决

## 让应用在 Kubernetes 中方便运行和管理
* 平衡调试和运行环境的关系,构建**尽可能小的容器镜像,并包含必要的调试工具**
* 合理的给**镜像打标签**,不使用latest标签最好能指定具体镜像版本
* 合理的多维度的给**资源打标签**,合理的调度pod 可包含以下内容
    * 资源的应用名称
    * 应用层级(前端,后端等)
    * 运行环境(开发,测试,生产,预发布等等)
    * 版本号
    * 发布类型(稳定版,金丝雀，蓝绿中的蓝色或绿色)
    * 租户
    * 分片
    * 其他的内容
* 通过注解描述每个资源。注解应该包含资源负责人,最好包含以来的其他的服务名,构建的版本信息等方便其他工具或图形界面使用的元信息
* 给进程终止提供更多的信息: 当应用突然崩溃时,调试其原因非常令人沮丧,开发过程中考虑在应用结束后将错误内容的简短信息写入`/dev/termination-log`这个默认路径(可以通过手动修改terminationMessagePath字段来定义写入的路径)此时失败信息会展示在 describe中。
* 使用中心化的日志系统(如elk)统一收集和管理应用日志

## 开发和测试的最佳实现
* 开发环境在kubernetes 之外
    * 通过环境变量或 service NodePort LoadBalancer 连接到其他服务
    * 通过serviceAccount 或ambassadorContainer 访问api-server
    * 通过将构建内容挂载的方式解决开发环境代码更改需要重新构建的问题
* 开发过程中使用 Minikube
    * 将本地文件挂载到MinikubeVM在挂载到容器中
    * 在MinikubeVM 中使用内部dockerDaemon构建
    * 本地构建好镜像后直接复制到MinikubeVM中
    * minikube和远程Kubenetes 汲取结合使用
* 使用版本管理工具(如git) 管理自动部署资源清单
* 使用工具辅助编写YAML文件
* 利用持续集成和持续交付

## 一些常见的命令
```bash
# 删除pod 并制定终止宽限期5s
kubectl delete po mypod --grace-period=5
# 强制pod立即删除不等待确认
kubectl delete po --grace-period=0 --force
# 将文件从本地复制到pod 中
kubectl cp localfile foo-pod:/etc/remote-file
# 将文件从远程pod复制到当前本地文件系统
kubectl cp foo-pod:/var/log/foo.log foo.log
```





