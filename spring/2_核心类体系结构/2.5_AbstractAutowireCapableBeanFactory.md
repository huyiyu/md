# AbstractBeanFactory

## 思考
* 简述 beanDefiniton 合并过程 从 stale 状态修改开始？
* 简述 getBean 的逻辑？
* beanDefinition 有了 scope 为什么还要 isSingleton 和 isPrototype,Bean 有几种scope?
## 属性
### parentBeanFactory 
>父 bean 工厂
### beanClassLoader 
>bean 的类加载器,默认从当前线程取,否则获取应用类加载器
### tempClassLoader 
>临时类加载器
### cacheBeanMetadata 
>是否缓存 Bean 的元数据
### beanExpressionResolver 
>bean 表达式解析器
### conversionService 
> 转换器
### propertyEditorRegistrars

### customEditors

### typeConverter
> 将Bean转化成预期类型的转换器,当 doCreateBean 有 requireType 参数时
### embeddedValueResolvers

### beanPostProcessors 
>要应用的BeanPostProcessors
### beanPostProcessorCache 
>分类好的beanPostProcessors 缓存
### scopes 
>将字符串映射成Scope对象的映射表,包括自定义注册的scope
### securityContextProvider

### mergedBeanDefinitions 
>合并的最终 bean 映射
### alreadyCreated 
>已经创建过的 bean 名称的集合,FactoryBean 的创建不会加入该列表
### prototypesCurrentlyInCreation 
>当前正在创建的 prototype 类型的bean
### applicationStartup 
>用于性能监控对象,默认没卵用
## 1.4.3 方法
### getBean: 
> 调用doGetBean 获取一个Bean,没有则创建,这个方法有多个重载,本身没有逻辑
```java
	public Object getBean(String name) throws BeansException {
		return doGetBean(name, null, null, false);
	}
	public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
		return doGetBean(name, requiredType, null, false);
	}
	public Object getBean(String name, Object... args) throws BeansException {
		return doGetBean(name, null, args, false);
	}
	public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)
			throws BeansException {
		return doGetBean(name, requiredType, args, false);
	}
```
#### transformedBeanName:
* name: bean名称,一般为小写简单类名
> 将 FactoryBean 的名称 & 符号去掉,FactoryBean 可能又会返回 FactoryBean 所以要多次去掉直到首个字符不为&,其次使用这个名称访问[canonicalName](2.1_SimpleAliasRegistry.md#canonicalName)获得最终类名
#### getObjectForBeanInstance
* object: 原始对象
* name: 获取的名称
* beanName: 通过 [transformedBeanName](#transformedBeanName) 后的名称，是AliasRegistry要求的规范名称
* mbd: 最终合并的RootBeanDefinition
> 尝试暴露 FactoryBean 需要代理创建的真正对象,判断类名是否携带&开头,是说明用户本意返回FactoryBean对象,则直接返回FactoryBean对象;如果原始对象不是FactoryBean直接返回,提升判断效率;否则 则传入的name不存在&,且原始对象刚好是FactoryBean,此时调用者想要获取FactoryBean创建出来的对象，首先访问 [getCachedObjectForFactoryBean](./2.3_FactoryBeanRegistrySupport.md#getCachedObjectForFactoryBean) 尝试从FactoryBean的缓存里面获取Bean，如果获取不到 调用[getObjectFromFactoryBean](./2.3_FactoryBeanRegistrySupport.md#getObjectFromFactoryBean)
#### doGetBean:
>提供getBean 调用,可接受四个参数（bean 名称,创建Bean的构造方法参数,bean 类型)
* name: bean 的名称
* requiredType: 预期返回的类型,如果不对,尝试调用转换器转换,如果没有则不检查类型
* args: 使用的创建bean的参数
* typeCheckOnly: 该参数仅在factoryBean调用时为 true,此时不会重新合并BeanDefinition,具体表现行为 markAsCreated 不执行。

##### 补充
  1. 调用 transformedBeanName 解析 bean 名称,首先去掉FactoryBean的 & 特殊符号开头,其次调用 canonicalName 转化成实际 bean 名称
  2. 尝试使用实际的名称,调用getSingleton(name)获取缓存中的对象,如果存在且创建参数为空,认为是该对象是单例,并且已存在,调 [getObjectForBeanInstance](#getObjectForBeanInstance)
  3. 判断当前对象处于 prototype 对象创建的 threadLocal 内部(是 prototype 且该对象正处于创建周期内);如果是抛异常，处于prototype 的循环
  * 如果有 parent BeanFactory 尝试从 parent BeanFactory 中获取(指重新走 parent BeanFactory 的getBean方法或 doGetBean 方法)
  * 如果不是 FactoryBean 调用 markBeanAsCreated (以下为创建Bean流程)
    1. 把 Bean 名称添加到alreadyCreated 集合里
    2. 把 BeanDefinition 的 stale 属性设置为 true 表示需要重新合并
  * 调用 getMergedLocalBeanDefinition 重新解析BeanDefinition 从BeanDefinitionMap  根据BeanName取出对应的BeanDefinition 然后转化成RootBeanDefinition
    * containingBd 为空时往 mergeBeanDefinitionMap 查询 BeanDefinition
    * stale 为 true 才会重新解析Bean Definition
    * 如果 原始的 bd 没有 parent
      1. 原始的 BD 是 rootBeanDefinition 那么直接调用RootBeandefinition 的CloneBeanDefinition
      2. 否则调用rootBeanDefinition 的使用父接口空构造(会比1少复制 RootBeanDefinition 的特有属性)
    * 有 parent 
      * parentBeanName 不等于自己 先解析ParentBeanName 解析的过程就是调用 getMergedLocalBeanDefinition,BeanDefinition 然后获得MergeBeanDefiniton
      * parentBeanName 等于自己,(很反人类的操作)从 parentBeanFactory 调用 getMergedLocalBeanDefinition 解析生成RootBeanDefiniton 然后调用 overrideFrom 子 Beandefinition 覆盖父 Beandefinition
    * 如果第二次解析要防止覆盖一些相关的属性如(isFactoryBean,targetType)
  * 调用 checkMergedBeanDefinition 检查这个RootBeanDefinition 是否是Abstract 的(是Abstract 报错)
  * 检查是否出现循环DependsOn 出现则报错
  * 调用getBean 先创建DependsOn的对象 此时进入递归
  * bean 是 singleton
    * 调用 getSingleton (带supplier 提供一个回调调用doCreateBean),使用getSingleton方法的目的是 将最终创建的对象加入一级缓存
    * 掉用  getObjectForBeanInstance 尝试从 FactoryBean 中获取Bean
  * bean 是 prototype 
    * beforePrototypeCreation: 这个方法会在当前 ThreadLocal 中存入当前对象，ThreeadLocal 的value 第一次存入时为String,多个创建时value为HashSet
    * 调用 createBean 创建对象
    * 掉用  getObjectForBeanInstance 尝试从 FactoryBean 中获取Bean
  * 都不是,属于自定义 scope 
    * 检查 BeanDefinition 是否有 scope 属性,没有报错
    * 检查 scope 是否有注册 没有注册报错
    * 调用当前scope 对象的get 方法,同时提供createBean回调,同时提供 threadLocal 监听回调,所以自定义 Scope 的bean 介于 singleton 和 prototype 之间,可了解一下RequestScope 和SessionScope 的生命周期
  * 调用 adaptBeanInstance 返回
    * 如果 requireType 为空 不操作
      * 否则检查获得的 Bean 类型是否匹配
      * 不匹配时尝试调用 Convertor 转换 转换失败报错