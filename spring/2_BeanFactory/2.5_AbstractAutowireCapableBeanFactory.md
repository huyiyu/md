# AbstractAutowireCapableBeanFactory
## 已实现接口
* AutowireCapableBeanFactory
## 思考
* aop 如何返回代理对象,从哪几个环节开始控制,基于什么情况创建的代理
* 如何判断Bean类型
* beanPostProcessor 在哪几个阶段执行分别干了什么事
* 三级缓存内部到底是什么,这么设计有什么好处
* aop有多少方式
## 属性
### factoryBeanInstanceCache 
> 缓存未完成的 FactoryBean 的 BeanWrapper

## 方法
### applyBeanPostProcessorsBeforeInstantiation
* beanClass: 当前对象类型
* beanName: 当前对象规范名称
> 获取所有 instantiationAware 类型的 InstantiationAwareBeanPostProcessor 循环执行[postProcessBeforeInstantiation]方法
### applyBeanPostProcessorsAfterInitialization
* beanClass: 当前对象类型
* beanName: 当前对象规范名称
> 获取所有 instantiationAware 类型的 InstantiationAwareBeanPostProcessor 循环执行[postProcessAfterInitialization]方法

### determineConstructorsFromBeanPostProcessors
* beanClass: 对应 Bean 的类类型
* beanName: 对应 Bean 的名称
> 推断给定 bean 的候选构造方法,先 调用[getBeanPostProcessorCache](./2.4_AbstractBeanFactory.md#getBeanPostProcessorCache) 获取 smartInstantiationAware 区域的所有 BeanPostProcessor,理论上会有一个 [AutowiredAnnotationBeanPostProcessor](../3_BeanPostProcessor/3.1_AutowiredAnnotationBeanPostProcessor.md) 循环执行方法[determineCandidateConstructors](../3_BeanPostProcessor/3.1_AutowiredAnnotationBeanPostProcessor.md#determineCandidateConstructors)





### resolveBeforeInstantiation
> 在对象实例化之前返回一个代理对象
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition
#### 补充
1. 判断 mbd 的 beforeInstantiationResolved 属性是否不为 false;该属性默认为空,所以一般此处成立
2. 判断 mbd 的 synthetic 属性为false(默认都为false) 并且调用[getBeanPostProcessorCache](./2.4_AbstractBeanFactory.md#getBeanPostProcessorCache) 判断 instantiationAware 区域不为空 如果为空直接跳过
3. 调用 [determineTargetType](#determineTargetType)获取真正类型
4. 先执行 [applyBeanPostProcessorsBeforeInstantiation](#applybeanpostprocessorsbeforeinstantiation) 结束后对象不为空执行 [applyBeanPostProcessorsAfterInitialization](#applyBeanPostProcessorsAfterInitialization)获取最终对象
5. 修改 beforeInstantiationResolved 属性为 bean != true;即如果成功创建代理对象该值为true 否则为false;返回该对象

### ***createBean (重点)***
> 此类的核心方法：创建一个 bean 实例，填充 bean 实例，应用后处理器
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition
* args: 构建参数
#### 补充
1. 调用 [resolveBeanClass](resolveBeanClass)获得BeanClass
2. 执行[prepareMethodOverrides](../1_beanDefinition%20介绍/1.1_AbstractBeanDefinition.md#prepareMethodOverrides) 和（lookup replace相关）
3. 调用 [resolveBeforeInstantiation](#resolvebeforeinstantiation) 尝试返回代理类
4. 调用 [doCreateBean](#doCreateBean) 尝试创建对象返回

### ***doCreateBean(重点)***
> 创建指定的Bean,此时预创建处理已经发生,检查 beanPostProcessor 的 beforeInstantaion 使用工厂方法或构造方法注入
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition
* args: 构建参数
### 补充
1. 如果是 singleton 尝试从 factoryBeanInstanceCache 获取 BeanWrapper
2. 如果没有调用[createBeanInstance](#createBeanInstance) 创建 BeanWrapper
3. BeanWrapper 调用[getWrappedInstance](./其他组件/BeanWrapper.md#getWrappedInstance)获取对象
4. BeanWrapper 调用[getWrappedClass](./其他组件/BeanWrapper.md#getWrappedClass)获取类型
5. 调用执行[applyMergedBeanDefinitionPostProcessors]()
6. 


### getTypeForFactoryMethod
> 确定基于工厂方法的 BeanDefinition 的targetType
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition
* typesToMatch: 匹配的对应类型

### determineTargetType
> 通过 mbd 确定最终类型
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition


#### 补充
1. 判断当前 mbd 拥有 targetType 如果没有,生成一个targetType存入RootBeanDefinition
   1. 如果是 FactoryBean 类型的 Bean 调用[getTypeForFactoryMethod](getTypeForFactoryMethod)生成
   2. 普通Bean 调用[resolveBeanClass](./2.4_AbstractBeanFactory.md#resolveBeanClass)生成
2. 如果[tempClassLoader](./2.4_AbstractBeanFactory.md#tempClassLoader)为空或没有匹配类型参数

### applyMergedBeanDefinitionPostProcessors
> 从 [beanPostProcessorCache](./2.4_AbstractBeanFactory.md#beanPostProcessorCache) 获取 mergedDefinition 接受  MergedBeanDefinitionPostProcessors 后处理


### obtainFromSupplier
### instantiateUsingFactoryMethod
### autowireConstructor
### instantiateBean


### createBeanInstance
* beanName: bean的规范名称
* mbd: 最终合并完成的 rootBeanDefinition
* args: 构建参数
> 创建对象,并放入BeanWrapper

#### 补充
1. 调用 [resolveBeanClass](#resolveBeanClass) 获取最终类型
2. 尝试获取 mbd 内部的 instanceSupplier,如果存在直接从 supplier 中获取需要创建的类返回[obtainFromSupplier](#obtainFromSupplier)
3. 如果 mbd的属性factoryMethodName 不为空,调用[instantiateUsingFactoryMethod](#instantiateUsingFactoryMethod)
4. 如果 mbd.instantiateUsingFactoryMethod 不为空
   1. mbd.constructorArgumentsResolved 为 true 调用[autowireConstructor](#autowireconstructor) 构造方法注入
   2. mbd.constructorArgumentsResolved 为 false 调用[instantiateBean](#instantiatebean) 反射创建
5. 调用[determineConstructorsFromBeanPostProcessors](#determineConstructorsFromBeanPostProcessors)获取推断构造方法,如果推断构造方法不为空,或 mbd.autowireMode 为 AUTOWIRE_CONSTRUCTOR 尝试使用[autowireConstructor](#autowireconstructor)
6. 当前对象如果是kotlin 对象,且拥有 primary构造器 尝试[autowireConstructor](#autowireconstructor)
7. 所有情况都不满足使用[instantiateBean](#instantiatebean)