# 走进 java NIO
本章包含以下内容：

* I/O 基础入门
* JAVA I/O 发展简史


## I/O 基础入门
> jdk 1.4之前 对高性能I/O程序的支持不够,开发者会面临以下问题,导致了高性能服务端开发领域长期被C和C++编写的程序占据

* 没有数据缓冲区,I/O 性能存在问题
* 没有 channel 的概念,只有输入和输出流
* 同步阻塞式 I/O 通信，会导致线程被长时间阻塞
* 支持字符集有限

### Linux 网络 I/O 模型简介
> linux 内核将所有外部设备都看作一个文件来操作,对一个文件的读写会调用内核系统命令返回一个文件描述符。而对socket的读写也会有相应的描述符称为 `socketfd` 描述符是一个数字，它指向了系统内核中的一个结构体(文件路径，数据区等一些属性)
根据 UNIX 网络编程对 I/O 模型的分类, UNIX 提供了 5 种 I/O 模型，分别如下

1. 阻塞 I/O 模型: 在进程空间内调用 `recvFrom`,其系统调用直到数据包到达且被复制到应用程序缓冲区中或者发生错误才返回,这个过程从调用 `recvFrom` 到它返回的整段时间都是阻塞的
2. 非阻塞 I/O 模型: `recvFrom`从应用层到内核的时候，如果缓冲区没有数据的话，就直接返回一个 EWOULDBLOCK 错误，一般对非阻塞 I/O模型进行轮询检查这个状态,看是否有数据到来
3. I/O复用模型: Linux 提供 select/poll,进程通过将一个或多个 fd 传递给 select/poll 系统调用,阻塞在select 操作上,由select/poll帮助侦测多个 fd 是否处于就绪状态,select/poll 扫描fd 是顺序扫描,支持的fd数量有所限制.为了解决这个问题,linux 提供epoll 模型,使用事件驱动代替顺序扫描，当 fd 就绪时，通过调用回调函数通知应用。**java NIO核心类库Selector基于epoll多路复用实现**
4. 信号驱动 I/O 模型：开启套接口驱动 I/O 功能,通过系统调用 `sigaction`执行一个信号处理函数。当数据就绪时，就为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 `recvFrom` 来读取数据
5. 异步I/O 模型: 告知内核启动某个操作，并让内核在整个操作 **完成后** 通知应用。

### I/O 多路复用技术
> I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。与传统多线程，多进程模型应用相比，I/O多路复用的最大优势是系统开销小，单线程操作，节省资源。

支持I/O多路复用的系统调用由 poll,select,pselect,epoll ，epoll 解决了 select 的一些缺陷总结如下：
* 支持一个进程打开的文件描述符不受限制
* I/O 效率不衰fd数目的增加而线性下降
* 使用内存映射加速内核与用户控件的消息传递
* epoll 的API更加简单

## JAVA I/O 发展简史

* jdk1.1-1.3: 仅有 BIO
* jdk1.4-1.6: 新增 java.nio 包提供进行异步开发的库
    * 进行异步I/O的缓冲区 ByteBuffer
    * 进行异步 I/O的管道 Pipe
    * 进行各种I/O 操作的 Channel 包含 ServerSocketChannel 和SocketChannel
    * 非阻塞 I/O 的多路复用器 Selector
    * 多种字符集的编码解码能力
    * 流行的Perl实现的正则表达式类库
    * 文件通道 FileChannel
* jdk 1.7: 升级nio 2.0
    * 提供批量获取文件属性的API
    * 提供 AIO功能,支持基于文件异步I/O操作和针对网络套接字的异步操作
    * 完成 JSR-51定义的通道功能，包括对配置和多波数据报的支持

