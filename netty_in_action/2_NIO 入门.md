# NIO 入门
> 本章中分别对JDK的 BIO，NIO和 NIO2.0 的使用进行详细的说明通过流程图和代码讲解，让读者体会到,随着JAVA I/O 类库的不断发展和改进，基于JAVA的网络编程会变得越来越简单；随着异步IO的增强，基于JAVA NIO开发的网络服务器甚至不逊色于采用 C++开发的网络程序

本章主要内容包括:
* 传统同步阻塞 I/O 编程
* 基于 NIO 的非阻塞编程
* 基于 NIO 2.0 的异步非阻塞(AIO) 编程
* 为什么使用NIO
* 为什么选择 Netty

## 传统同步阻塞 I/O 编程
> 采用BIO编程模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端连接，它接收到客户端请求后为每个客户端创建一个新的线程进行链路处理，处理完成之后通过输出流响应给客户端，线程销毁。
该模型的最大问题是缺乏弹性伸缩的能力，JVM和操作系统的线程是一一对应的,当请求到达一定数量时,频繁的创建线程销毁线程对系统开销影响极大。随着并发数量的递增，系统性能将急剧下降。不断发生堆栈溢出，创建新线程失败等问题。并最终导致进程宕机或僵死，不能对外提供服务。
通过使用线程池来复用线程，避免频繁的创建或销毁实现一个伪异步的效果,可以解决掉上述线程频繁创建导致的问题。
但无法从根本上解决同步I/O 导致的通信线程阻塞的问题。在多系统通信返回应答时间过长会引起级联故障

1. 故障服务器处理请求缓慢返回应答60s
2. 伪异步服务请求故障节点，此时被同步阻塞60s
3. 假如所有可用线程都被故障服务器阻塞，后续 I/O消息都将在队列中排队
4. 由于线程池采用阻塞对了实现队列积满之后后续入队操作都被阻塞
5. Acceptor 线程阻塞在阻塞队列之后 新的客户端请求消息触发拒绝策略，客户端发生大量连接超时
6. 由于有几乎所有连接都超时，调用者认为系统已经崩溃，无法接受新的请求消息

## 基于 NIO 的非阻塞编程
> 官方所认为的 nio 是New I/O 区别于传统IO,开发人员更喜欢将其认为是 Non-Block I/O
NIO 同样提供SocketChannel和ServerSocketChannel两种不同的套接字通道实现。新增的通道支持阻塞和非阻塞两种模式,阻塞模式使用非常简单，但可靠性和性能相对不好。非阻塞正好相反。

### NIO类库简介
#### 1. 缓冲区buffer
> 在 NIO中所有数据都是用缓冲区处理的。在读取数据时直接读到缓冲区中；同样在写入数据时也是从缓冲区内部读取。 缓冲区本质上是一个数组，包含了三个指针,通过控制指针的相对位置读取数据。

* capacity： 最大容量，它永远不可能为负数，并且是不会变化的
* limit：  限制，它永远不可能为负数，并且不会大于capacity
* position：下一个读或写的位置，它永远不可能为负数，并且不会大于limit

#### 2.通道 channel
>
#### 3. 多路复用器 Selector
>
## 基于 NIO 2.0 的异步非阻塞(AIO) 编程
## 为什么使用NIO
## 为什么选择 Netty